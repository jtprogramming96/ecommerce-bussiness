- Al crear el datasource, lb me pedirá el conector a la fuente de datos(bd: mongo, postgresql, etc), automatizándome esa parte.
- Repositorios( sería algo así como el DTO): serían los CRUDS de los modelos.

- SERVICE PROXY: es como el repositorio, pero para los servicios de terceros (notificaciones sms, push, de email por ejemplo
de Amazon Web Services (AWS)).

# AL CREAR LAS ENTIDADES:
- NO se deben agregar las foreign key, ya que al establecer las relaciones, se añaden automáticamente. Solo
deben indicarse los campos propios de la entidad que estamos creando.
- Se deben crear tanto las entidades principales, como las que representen a las relaciones n a n, teniendo cuidado de, en estas
últimas, solo crearle los campos propios de la tabla, no añadiendo las fks de las entidades que PERTENEZCAN al mismo microservicio
(ya que se añadirán de forma automatica al establecer las RELACIONES) pero si las las entidades que pertenezcan a otros microservicios.

# CREANDO CAMPO:
	- al poner que no es necesario, opcionalmente podemos indicarle un valor por defecto.
	- EN MONGODB, el id debemos especificarlo como _id y de tipo string, ya que mongoDB trabaja los id de las entidades a través del
	objeto objectId, el cual tiene el atributo _id de tipo ALFANUMÉRICO que ocupa 12 bytes.

EDITAR CAMPO:
	- SI TE EQUIVOCASTE EL TIPO DEL CAMPO, no hay problema, podes cambiarlo desde el modelo (siempre y
	cuando el resto esté bien).
	- ELIMINAR CAMPO: si por ejemplo pusiste una property que no va, la eliminas del modelo, punto.
	- FK DE UN MODELO DE UN MS EN OTRO MODELO DE OTRO MS:
	En el modelo que tiene la fk, se coloca normalmente el atributo (por ej id_cliente) con el tipo apropiado (number en este caso),
	porque luego se usará para referenciar al modelo (Cliente en este caso) de otro microservicio (ms-clientes en este caso).
	- - Y EN LA BASE DE DATOS, SE RELACIONA LAS RESPECTIVAS TABLAS CON SQL (YA QUE LB4 NO LO HACE), así:
		alter table `Factura` add CONSTRAINT `fk_factura_id_cliente` FOREIGN KEY (id_cliente) REFERENCES `Cliente`(id);		// Añade la fk del cliente a la factura. (de ms-cliente a ms-factura)
		alter table `ProductoFactura` add CONSTRAINT `fk_productoFactura_id_producto` FOREIGN KEY (id_producto) REFERENCES `Producto`(id);	// Añade la fk del producto al itemProducto de la factura (de ms-producto a ms-factura)

# REPOSITORIOS:
	
- un repositorio relaciona un datasource declarado (por ejemplo una bd postgres, o mysql) con un conjunto
de entidades declaradas.

# DATASOURCES:
Un datasource es una fuente de datos, por ejemplo una bd postgres, o mysql.
Si es MySQL, por ejemplo: debo indicar los parámetros de conexión CORRECTOS: host, puerto, password, etc.
En mongoDB, no es necesario hacer "migrate", ya que basta indicar el nombre de la db y él se encarga de crearla y mantener actualizado
todo lo relacionado a ella.

# RELACIONES:
En lb4, es recomendable hacer las relaciones en ambos sentidos(aunque parezca redundante), para tener acceso
a todas las funcionalidades que nos proporciona el framework(lb4).
	- hasManyThrough: relación que se usa para los modelos que representan relaciones n a n (dicho modelo, es el "modelo intermedio"),

# CONTROLLERS:
* En MySQL: NO crea la base de datos automaticamente. Para ello se debe migrar lo haceho en lb4 a MySQL de la siguiente forma:
	1: npm run build	// compila el proyecto
	2: npm run migrate	// migra lo definido en la carpeta "models" a la db. (Luego de este paso, debería ver la bd y las tablas creadas).
	3: npm start		// para iniciar la aplicación: podremos servirnos de API creada
* En MongoDB: SÍ crea la bd automáticamente.

## acciones a db:
	updateById: busca y actualiza un objeto que tenga el id dado contra los atributos del objeto dado (no se cambia el id, ya que debería ser pk y bla bla)

# USO DEL EXPLORER PROPORCIONADO POR LB4 PARA EL API:
- get: Por defecto, lb4 provee un filtro. Debemos dejarlo así: {}
	para que nos devuelva todos normalmente.
- put (para modificar una fila):  buscará por el id especificado. Y en el request body (cuerpo de la solicitud)
	se debe en especificar los campos q modificar, con sus respectivos nuevos valores (NO se debe
	añadir el id, ya que es PK y lo suele mostrar por defecto [SER CUIDADOSO CON ESTO]).
	
#EXTRAS:
PHPMYADMIN:
	- HERRAMIENTA DE DISEÑO VISUAL: al seleccionar la BD podemos crearle un diagrama de ER en la solapa "Más"-> "Diseñador". No se mostrarán
	las relaciones (flechas) entre las tablas ya que lb4 no configura esto, debemos hacerlo a mano. PARA LO QUE VIENE A CONTINUACIÓN, DEBERIAMOS
	tener migrados los modelos a la BD (los pasos 1,2 y 3 de la sección de MySQL, CONTROLLERS, 2 hashtags más arriba)(ver NOTA al final), una vez cumplido esto, seguimos:
	
	Por ejemplo, dentro de los paréntesis del decorador "model()" del modelo CategoriaProducto, colocamos: 
	{
	  settings: {
	    foreignKeys: {
	      fk_cat_prod_id_producto: {	// fk id_producto en la tabla cat_prod(uso este apodo en lugar de categoria_producto porque es muy largo)
		name: 'fk_cat_prod_id_producto',	// la nombro como el objeto (copio de la línea anterior)
		entity: 'Producto',			// entidad a la que hace referencia
		entityKey: 'id',			// nombre de la pk en la entidad (en este caso la pk de Producto es 'id'
		foreignKey: 'id_producto',	// debo tener definido 'id_producto' en la tabla actual en cuestión
	      },
	      fk_cat_prod_id_categoria: {	// fk id_categoria en la tabla cat_prod
		name: 'fk_cat_prod_id_categoria',	// aquí en adelante, se debe cumplir todo lo anterior pero para la fk id_categoria
		entity: 'Categoria',
		entityKey: 'id',
		foreignKey: 'id_categoria',
	      },
	    },
	  },
	})

	El ejemplo anterior es porque el modelo tiene claves foráneas a los modelos Producto y Categoria.
	
	En Imagen sería:
	{
	  settings: {
	    foreignKeys: {
	      fk_prod_id_producto: {
		name: 'fk_imagen_id_producto',
		entity: 'Producto',
		entityKey: 'id',
		foreignKey: 'id_producto',
	      }
	    },
	  },
	}
	
	UNA VEZ AÑADIDAS LAS FK, ejecutar el servicio:
	1 compilar: npm run build
	2 ejecutar: npm run migrate
	
	LOS PASOS SON:
	a Crear modelos
	b Migrar a DB
	c ENTONCES puedo hacer lo del paso "HERRAMIENTA DE DISEÑO VISUAL" (para establecer las llaves foráneas(fk))
	d Vuelvo a migrar a DB (para que las fk se vean reflejadas en la DB)
	
	NO PUEDO HACER LOS PASOS a y c al mismo tiempo y hacer el paso d, ya que primero deben existir dichas tablas(paso a) para poder
	relacionarlas a través de fk's (paso c).
	
	NOTA: lo mismo ocurre al clonar el proyecto. Primero comentamos TODO lo que está dentro del paréntesis de model(), run build,
	migrate y entonces descomentamos lo de dentro del paréntesis de model() y nuevamente migrate(al parecer, no es necesario
	rebuildear, porque solo estamos modificando los modelos, entoces, migrate sería suficiente ya que refleja cualquier cambio en
	los modelos hacia la bd), ese sería el orden correcto y para que todo ande OK (sino ver video 15 minuto 14:10).
